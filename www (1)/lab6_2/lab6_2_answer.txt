3.Какая разница между Datetime или timestamp?
- Разница заключается в способе хранения информации и в других мелочах.
DATETIME хранит время в виде целого числа вида YYYYMMDDHHMMSS, используя для этого 8 байтов.
Это время не зависит от временной зоны.
Оно всегда отображается при выборке точно так же, как было сохранено,
независимо от того какой часовой пояс установлен в MySQL. 
TIMESTAMP хранит 4-байтное целое число, равное количеству секунд, 
прошедших с полуночи 1 января 1970 года по усреднённому времени Гринвича
(т.е. нулевой часовой пояс, точка отсчёта часовых поясов).
При получении из базы отображается с учётом часового пояса.
Часовой пояс может быть задан в операционной системе,
глобальных настройках MySQL или в конкретной сессии.


5.NULL-значения для атрибутов внешнего ключа допустимы только в том случае, 
когда атрибуты внешнего ключа не входят в состав никакого первичного ключа.
Может, если на данный столбец не наложено ограничение not null, 
пример: при построении таблицы дерева файловой системы, 
где столбец foreign key - ссылка на эту же самую таблицу,
на кортеж с информацией о родительской директории,
тогда для корневой директории файловой системы в столбце родительской директории будет - null.



6.Cтолбцы в реляционных базах данных очень часто содержат одинаковые значения в разных строках.
Очень часто требуется получить в результате выполнения запроса строку данных, которая будет уникальной.
Структура запроса с удалением дубликатов строк следующая:
SELECT DISTINCT columnsName FROM tableName; где: 
columnsName - одно или несколько реальных имен столбцов,перечисленных через запятую;
tableName - имя той таблицы, из которой выбираются эти столбцы.

Если в предложение SELECT DISTINCT включить более одного столбца, 
то в результате уникальность любой строки будет определяться уникальностью соответствующей
комбинации всех значений столбцов, включенных в предложение, на этой самой строке среди 
аналогичных комбинаций, соответствующих другим строкам. 

Несмотря на то что значения null никогда не бывают равны друг другу (поскольку считаются неизвестными),
предложение DISTINCT , напротив, считает их дубликатами. Поэтому команда SELECT DISTINCT вернет только
одно значение null, независимо от того, сколько значений null она встретит.

Синтаксис команды SELECT содержит необязательное ключевое слово ALL.
Это слово указывает на действие, которое является действием по умолчанию 
(то есть было бы выполнено и без всяких указаний): отобразить все строки, в том числе дубликаты.
То есть запрос SELECT columnsName FROM tableName; эквивалентен запросу 
SELECT ALL columnsName FROM tableName, а синтаксическая диаграмма такова:
SELECT [ALL | DISTINCT] columnsName FROM tableName.

Если в таблице произвольной базы данных первичный ключ определен правильно, 
то каждая строка этой таблицы будет уникальной. Поэтому запросы SELECT DISTINCT * FROM tableName;
 и SELECT * FROM tableName; вернут для такой таблицы один и тот же результат.

p.s. 
удалить с таблицы дублируещие строки, а не с результатов выборки
(чтобы в самой таблице не осталось дубликатов), в итоге нет такого подхода с distinct. 
По этому нужно указать в описании, откуда необходимо удалить строки
(и удалить или все же отобразить уникальные строки).



8. Конструкцию HAVING можно использовать только при наличии конструкции GROUP BY. 
Она действует по отношению к результатам конструкции GROUP BY аналогично тому, 
как конструкция WHERE отсеивает строки, возвращаемые оператором SELECT, в соответствии 
с указанным условием.

HAVING - применяется для фильтрации функций и столбцов сгруппированных при помощи GROUP BY 
указанных в SELECT.
Другими словами применяется для агрегатных функций(COUNT(), MAX() ...) и столбцов указанных
в выражении SELECT и обработанных GROUP BY. Если нужно использовать что-то, что не указанно в SELECT,
то лучше использовать WHERE.

Порядок выполнения такой:
1. В SELECT указываем нужные столбцы или агрегатные функции
(то с чем будем работать в GROUP BY и HAVING)
2. В GROUP BY пишем по какому столбцу или функции их группируем
3. В HAVING пишем условие фильтровки результата GROUP BY 

Применяется последним и не оптимизируется. 
При использовании не по назначению на больших таблицах будут жуткие тормоза.